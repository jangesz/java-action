1. jackson map pojo jsonobject
2. jackson有mapper，可以实现json，java object和xml之间的自由转换
3. http://www.baeldung.com/jackson-object-mapper-tutorial
4. http://stackoverflow.com/questions/32042938/elegant-mapping-from-pojos-to-vertx-ios-jsonobject
5. 疑惑不在于转换，而是不定义Pojo的话好多其他相关的地方都走不通，比如写tornadoFX时，没有定义Person的话，就不能定义Person的ModelView
  【答复】：这个没办法，这个是API的问题，就是两边定义不一样，所以大家要转换，这个是一直存在的，所以这就是to B生意不好做的原因。
  【怎么理解】：每个公司企业都有自己的搞法，然后你又不能challenge这些东西，因为你要做他得生意，他说了算，to C的话，不可能说每个人自己
  定义自己的标准吧？所以容易形成一种共识，那迎合这种共识就容易多了。而且这种共识一般都是木板最短的一块，往往标准是很少的。to B的生意，往往
  是几个大客户贡献了大多数的利润，但是每个客户都不一样，你哪个都得罪不起，但是to C的生意就容易一点，因为就算有20%的人不干，还有80%的能够
  接受，那剩下的20%的人慢慢他们也就接受了。JSON就是这么来的。

  原来的人写了一大坨东西在里面，后来的人没有人愿意碰，但是不碰又不行，所以最后就变成人都投入在旧的维护上了，最后就是这个成本撑不住了，业务要
  么就干脆不发展了。

  所以mastercard定期会自我革命一下，淘汰一部分东西，在市场上它对比起创业公司来说，才有一定的竞争力。mastercard也看到了，这些旧的维护成本，
  是创业公司不需要去投入的。当然这个东西不是一家公司，一个人的问题，是社会的现状，很多时候无力改变，但是有机会的时候，可以尝试一下。

  钢铁雄心


6. EventBus是通信方式，核心是Immutable，你用sharedmap也是一样的。rxjava自身面临问题，就是太过于接近fp了，不是特别多人能够接受Immutable
+ reactive的方式。至少coroutine在搞出来之后，展现出了它优秀的一面。你看一下go，所以如果在reactive和coroutine这两个上押宝，我倾向于后者。

7. orm只要是nosql支持到位，就不会那么麻烦。

8. eventbus和sharedmap这些都是immutable，线程间通信，倾向于immutable，而不是lock

9. file system主要是并发起来，没有lock和transaction这些，会有些小痛苦，但是好处是安装方便，给一个jar完全无依赖。并发处理可以交给Vert.x
处理

10. vertx防御DDOS
    1. 比如可以count一下，每个ip的请求次数，在一定时间段内。超过多少，直接封掉。
    2. 还有，可以不响应它，直接end，你没有成本，它攻击你有成本。
    3. ddos每个请求的大小要控制，要迫使对方拼命发请求，而不是一个请求特别大
    4. 限制请求的大小
    5. 如果应用只针对手机，可以对请求头做设置
    6. vertx是不会爆掉内存的，你带宽够，CPU就够

11. 用传统方式，启线程，然后把EventBus传给线程，在自己的线程内调用EventBus.send()，这个操作有啥问题吗？
    【答复】：不会有什么问题，这样等于你自己做了一个worker，因为是Immutable的message，所以线程安全。

    多个线程，用同一个EventBus的句柄发送消息呢？
    【答复】：线程和线程之间，只要是immutable的message，就没有问题。这个跟是不是eventbus，是不是vert.x的thread，包括eventloop和
    worker thread无关。

    用immutable的目的就是不用Lock，用Immutable和lock的目的就是线程之间并发处理要安全。你用了Immutable，就表示线程间并发操作是安全的。

12. 一个进程里最多能创建多少个verticle？比如游戏开房间，能为每个房间创建一个verticle吗？
    【答复】：可以，verticle本质上就是一个对象而已。但是超过线程数的verticle数量没有太大意义。
    eventbus本质上就是一个concurrent的hashmap。

    verticle一般理解是数量小于等于eventloop的数量

    你直接在verticle内部用map分房间就行了，比如100个房间，10个verticle。每个verticle内存存10个房间就行了。

13. 一个公司呢，如果没有技术基础，很容易被其它公司所绑架，就像鹅厂，渠道的费用是90%一样，你爱用不用。所以现在公司都是自建技术基础。
    以防止自身被其它公司绑架。所以知道为什么鹅厂可以万亿而其它游戏公司都处于崩溃的边缘了吧？所以就说了，一个企业要有自己的护城河，
    要能够to B的同时也能to C，这就是为啥我们要从infra搞起的原因，没有infra，什么都是别人的，别人说变就变了，你能怎么样？

    渠道费用是什么？用人家的平台，东西是你的，然后人家拿9，你拿1。就是你要去QQ上作广告，常见的就是游戏，然后游戏的利润分成，你1，它9。
    而且你爱用不用，不用人家也不求你用。

14. 传统的线程模型是一个请求，一捅到底，请求和请求之间如果需要通信，用Lock。这样做性能很差，而且人阅读代码起来不太容易。是一种横向的状态
    切割，而eventloop是一种纵向的状态切割，这样做，对开发人员要求变高了，但是性能和代码可读性上都要强很多。因为线程变少了，lock相应减少了，
    线程空转等待的时间也变少了。然后再通过verticle把逻辑封装起来，verticle之间如果必须通信，则通过immutable。用这种方式，不管是可读性
    还是性能都能飙升。唯一麻烦的就是要求员工需要了解这些原理。

    这个对于大公司来说，里面混日子的居多，所以没有这个动力去提升自己。

    对于创业公司来说，不做就是死路一条

    对于年轻人来说，这是一个弯道超车的好机会

    从这个利益出发，就适合搞vert.x。甩掉历史包袱，赶紧上。

    vert.x做游戏，realtime pvp都没有问题

    下个Scene Build画去吧，手写了fxml一个月，终于释放双手了。fxml一对毛病

15. vertx的filesystem操作文件真是牛，1秒能写入10几万行

    硬盘IO大概是10万左右
    内存IO就是千万左右
    网络IO一般是千次乃至百次左右

16. 二分法异步查找文件
    要递归，用coroutine
    要递归，还要带返回值

    java的递归不是真递归，只是放入一个queue而已。

    coroutine就能在callback时候返回值了。



